js书籍
===

# 你不知道的javascript

## 1、作用域

### 1.1  js的执行分为两个阶段

*   编译阶段，编译阶段会处理代码中的声明，并把变量放置与作用域中存储；并生成可被js引擎执行的代码
```
  var x = 2;// 编译阶段处理var x ，对x进行声明 ，x = 2 为赋值语句，需要js引擎去执行
  function foo (a) {console.log(a)};// 编译阶段对函数进行声明，声明的同时对其已经赋值了（函数特殊）
  
```
*   js引擎执行阶段，引擎执行编译生成的代码；引擎执行时，面对变量会在作用域内进行查找
>   查找分为LHS引用，和RHS引用；简单来说LHS，找到变量容器本身，并进行赋值；RHS则是找到源式值
>   函数执行时，函数内部的代码会再次执行一次，同样也会走编译--执行的流程；

*   函数的词法作用域，无论函数在哪里被调用，也无论它被如何调用，它的词法作用域只是由函数被声明时所处的位置所决定的；（作用域是由编译阶段所确定的，也是由书写时函数声明的位置所决定的，编译的词法分析阶段基本能够知道全部的标示符在哪里以及是如何声明的，从而能够预测在执行过程中如何对他们进行查找）
*   不要使用`with` 和 `eval`，这样会使得程序无法对代码进行优化；

### 1.2 闭包

> 无论通过何种方式将内部函数传递到所在的词法作用域之外，它都会持有对原始作用域的引用，无论在何处
> 由于函数可以被当成第一级的值并到处传递，那么函数在执行时，会带有对：由函数定义时形成的词法作用域的引用，这就是闭包
> 只要使用了**回调函数** 就是在使用闭包

*   无论函数是具名函数还是匿名函数，实际上都牵扯到了函数的定义，通常情况下，匿名函数不仅在声明函数而且会把函数传递到对应执行器中去；比如
*   函数的作用域，是由函数定义时决定的，也就是位置决定的
```
setTimeout(function () {...}, 1000);// 实际上当执行到此的时候，同样会对函数进行定义，只不过没办法在此引用这个函数，并且函数会被传递到执行器中
axios.get(url).then(function () {...})

```
*   闭包也可以这样去理解，当函数作为值进行传递的时候，函数的作用域如何处理
*   到了ES6，`let` 和 `const` 会使得代码块`{}` 变成块级作用域，同样会实现闭包的效果
*   通过JS的任何值都能作为返回值的特性，使用函数可以实现模块的功能（当然ES6 module是原生实现）模块
*   ES6模块：1、js原生支持的；2、js运行时，编译器会在编译阶段检查导入的模块API成员的引用是否存在，若不存在会抛出早期的错误；
*   
```
function module () {
    var a = '12';
    var b = [1,2,5];
    
    function doSomething () {
        ...
    }
    
    
    function doElseSomething () {
        console.log(a);
    }
    
    return {
        doSomething: doSomething,
        doElseSomething: doElseSomething
    }
}
var x = module();
x.doSomething();

```
## 3、对象


